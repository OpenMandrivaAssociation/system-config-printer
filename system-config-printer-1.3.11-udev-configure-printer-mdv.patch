diff '-Nurpx*~' system-config-printer-1.3.11/configure.in system-config-printer-1.3.11-f/configure.in
--- system-config-printer-1.3.11/configure.in	2012-03-01 16:16:35.000000000 +0200
+++ system-config-printer-1.3.11-f/configure.in	2012-03-26 04:33:06.383773297 +0300
@@ -33,6 +33,8 @@ AC_SUBST(DESKTOPVENDOR)
 AC_SUBST(cupsserverbindir)
 
 PKG_CHECK_MODULES(GLIB, glib-2.0, has_glib=yes, has_glib=no)
+PKG_CHECK_MODULES(DBUS, dbus-1, has_glib=yes, has_glib=no)
+PKG_CHECK_MODULES(DBUSGLIB, dbus-glib-1, has_glib=yes, has_glib=no)
 
 AC_ARG_WITH(udev-rules,
 	    [AC_HELP_STRING([--with-udev-rules],
diff '-Nurpx*~' system-config-printer-1.3.11/Makefile.am system-config-printer-1.3.11-f/Makefile.am
--- system-config-printer-1.3.11/Makefile.am	2011-10-26 15:14:19.000000000 +0300
+++ system-config-printer-1.3.11-f/Makefile.am	2012-03-26 04:33:06.383773297 +0300
@@ -182,8 +182,8 @@ udevrulesdir=$(sysconfdir)/udev/rules.d
 udevrules_DATA=udev/70-printers.rules
 udev_udev_configure_printer_SOURCES=\
 	udev/udev-configure-printer.c
-udev_udev_configure_printer_LDADD= -lcups -ludev $(libusb_LIBS) $(GLIB_LIBS)
-udev_udev_configure_printer_CFLAGS= $(AM_CFLAGS) $(libusb_CFLAGS) $(GLIB_CFLAGS)
+udev_udev_configure_printer_LDADD= -lcups -ludev $(libusb_LIBS) $(GLIB_LIBS) -ldbus-glib-1 -ldbus-1
+udev_udev_configure_printer_CFLAGS= $(AM_CFLAGS) $(libusb_CFLAGS) $(GLIB_CFLAGS) $(DBUS_CFLAGS) $(DBUSGLIB_CFLAGS)
 udevhelperdir=$(sysconfdir)/udev
 udevhelper_PROGRAMS=\
 	udev/udev-configure-printer

--- a/udev/udev-configure-printer.c	2012-10-05 14:30:19.000000000 +0400
+++ b/udev/udev-configure-printer.c	2012-11-24 05:19:58.582948047 +0400
@@ -51,11 +51,19 @@
 #include <libusb.h>
 #include <glib.h>
 #include <dirent.h>
+#include <dbus/dbus.h>
 
 #define DISABLED_REASON "Unplugged or turned off"
 #define MATCH_ONLY_DISABLED 1
 #define USB_URI_MAP "/var/run/udev-configure-printer/usb-uris"
 
+#define DBUS_PATH_ORG_FREEDESKTOP_DBUS "/com/redhat/NewPrinterNotification"
+#define DBUS_INTERFACE_ORG_FREEDESKTOP_DBUS "com.redhat.NewPrinterNotification"
+#define DBUS_SERVICE_ORG_FREEDESKTOP_DBUS "com.redhat.NewPrinterNotification"
+
+static char * global_make = "";
+static char * global_model = "";
+
 #if (CUPS_VERSION_MAJOR > 1) || (CUPS_VERSION_MINOR > 5)
 #define HAVE_CUPS_1_6 1
 #endif
@@ -985,6 +993,357 @@
   return answer;
 }
 
+static void
+PrinterEnabled ()
+{
+  syslog (LOG_DEBUG, "PrinterEnabled()");
+  DBusMessage *message = NULL;
+  DBusConnection *connection = NULL;
+  DBusError error;
+  
+  dbus_error_init (&error);
+  connection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
+  message = dbus_message_new_method_call (DBUS_SERVICE_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_PATH_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_INTERFACE_ORG_FREEDESKTOP_DBUS,
+                                          "PrinterEnabled");
+  if (message == NULL)
+    goto finish_error1;
+
+  dbus_message_append_args (message,
+                            DBUS_TYPE_STRING, &global_make,
+                            DBUS_TYPE_STRING, &global_model, DBUS_TYPE_INVALID);
+
+  if (!dbus_connection_send (connection, message, NULL))
+  {
+      dbus_message_unref (message);
+      message = NULL;
+  }
+    
+finish_error1:
+  if(message)
+      dbus_message_unref (message);
+}
+static void
+PrinterDisabled ()
+{
+  syslog (LOG_DEBUG, "PrinterDisabled()");
+  DBusMessage *message = NULL;
+  DBusConnection *connection = NULL;
+  DBusError error;
+  
+  dbus_error_init (&error);
+  connection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
+  message = dbus_message_new_method_call (DBUS_SERVICE_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_PATH_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_INTERFACE_ORG_FREEDESKTOP_DBUS,
+                                          "PrinterDisabled");
+  if (message == NULL)
+    goto finish_error2;
+
+  dbus_message_append_args (message,
+                            DBUS_TYPE_STRING, &global_make,
+                            DBUS_TYPE_STRING, &global_model, DBUS_TYPE_INVALID);
+
+  if (!dbus_connection_send (connection, message, NULL))
+  {
+      dbus_message_unref (message);
+      message = NULL;
+  }
+    
+finish_error2:
+  if(message)
+      dbus_message_unref (message);
+}
+static void
+InstallSpoolerFailed ()
+{
+  syslog (LOG_DEBUG, "InstallSpoolerFailed()");
+  DBusMessage *message = NULL;
+  DBusConnection *connection = NULL;
+  DBusError error;
+  
+  dbus_error_init (&error);
+  connection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
+  message = dbus_message_new_method_call (DBUS_SERVICE_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_PATH_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_INTERFACE_ORG_FREEDESKTOP_DBUS,
+                                          "InstallSpoolerFailed");
+  if (message == NULL)
+    goto finish_error3;
+
+  if (!dbus_connection_send (connection, message, NULL))
+  {
+      dbus_message_unref (message);
+      message = NULL;
+  }
+    
+finish_error3:
+  if(message)
+      dbus_message_unref (message);
+}
+
+static void
+SpoolerStartFailed ()
+{
+  syslog (LOG_DEBUG, "SpoolerStartFailed()");
+  DBusMessage *message = NULL;
+  DBusConnection *connection = NULL;
+  DBusError error;
+  
+  dbus_error_init (&error);
+  connection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
+  message = dbus_message_new_method_call (DBUS_SERVICE_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_PATH_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_INTERFACE_ORG_FREEDESKTOP_DBUS,
+                                          "SpoolerStartFailed");
+  if (message == NULL)
+    goto finish_error4;
+
+  if (!dbus_connection_send (connection, message, NULL))
+  {
+      dbus_message_unref (message);
+      message = NULL;
+  }
+    
+finish_error4:
+  if(message)
+      dbus_message_unref (message);
+}
+
+dbus_bool_t
+InstallSpooler ()
+{
+  syslog (LOG_DEBUG, "InstallSpooler()");
+  DBusMessage *message = NULL;
+  DBusMessage *reply = NULL;
+  DBusPendingCall *pending_call = NULL;
+  DBusConnection *connection = NULL;
+  DBusError error;
+  dbus_bool_t ok = FALSE;
+  
+  dbus_error_init (&error);
+  connection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
+  message = dbus_message_new_method_call (DBUS_SERVICE_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_PATH_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_INTERFACE_ORG_FREEDESKTOP_DBUS,
+                                          "InstallSpooler");
+  if (message == NULL)
+    goto finish_error5;
+
+  if (!dbus_connection_send_with_reply (connection, message, &pending_call, 360000))
+  {
+    dbus_message_unref (message);
+    goto finish_error5;
+  }
+ 
+  if (pending_call == NULL)
+    goto finish_error5;
+
+  dbus_pending_call_block(pending_call);
+
+  reply = dbus_pending_call_steal_reply(pending_call);
+  if (reply == NULL)
+    goto finish_error5;
+
+  dbus_message_get_args (reply, NULL,
+                             DBUS_TYPE_BOOLEAN, &ok,
+                             DBUS_TYPE_INVALID);
+finish_error5:
+  if(message)
+      dbus_message_unref (message);
+  if(reply)
+      dbus_message_unref (reply);
+  if(pending_call)
+      dbus_pending_call_unref (pending_call);
+  return ok;
+
+}
+dbus_bool_t
+CheckAndInstallDrivers ()
+{
+  syslog (LOG_DEBUG, "CheckAndInstallDrivers()");
+  DBusMessage *message = NULL;
+  DBusMessage *reply = NULL;
+  DBusPendingCall *pending_call = NULL;
+  DBusConnection *connection = NULL;
+  DBusError error;
+  dbus_bool_t ok = FALSE;
+  
+  dbus_error_init (&error);
+  connection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
+  message = dbus_message_new_method_call (DBUS_SERVICE_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_PATH_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_INTERFACE_ORG_FREEDESKTOP_DBUS,
+                                          "CheckAndInstallDrivers");
+  if (message == NULL)
+    goto finish_error6;
+
+  dbus_message_append_args (message,
+                            DBUS_TYPE_STRING, &global_make,
+                            DBUS_TYPE_STRING, &global_model, DBUS_TYPE_INVALID);
+
+  if (!dbus_connection_send_with_reply (connection, message, &pending_call, 360000))
+  {
+    dbus_message_unref (message);
+    goto finish_error6;
+  }
+ 
+  if (pending_call == NULL)
+    goto finish_error6;
+
+  dbus_pending_call_block(pending_call);
+
+  reply = dbus_pending_call_steal_reply(pending_call);
+  if (reply == NULL)
+    goto finish_error6;
+
+  dbus_message_get_args (reply, NULL,
+                             DBUS_TYPE_BOOLEAN, &ok,
+                             DBUS_TYPE_INVALID);
+finish_error6:
+  if(message)
+      dbus_message_unref (message);
+  if(reply)
+      dbus_message_unref (reply);
+  if(pending_call)
+      dbus_pending_call_unref (pending_call);
+  return ok;
+}
+
+static void
+MissingDriver()
+{
+  syslog (LOG_DEBUG, "MissingDriver()");
+  DBusMessage *message = NULL;
+  DBusConnection *connection = NULL;
+  DBusError error;
+  
+  dbus_error_init (&error);
+  connection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
+  message = dbus_message_new_method_call (DBUS_SERVICE_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_PATH_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_INTERFACE_ORG_FREEDESKTOP_DBUS,
+                                          "MissingDriver");
+  dbus_message_append_args (message,
+                            DBUS_TYPE_STRING, &global_make,
+                            DBUS_TYPE_STRING, &global_model, DBUS_TYPE_INVALID);
+
+   if (message == NULL)
+    goto finish_error7;
+
+  if (!dbus_connection_send (connection, message, NULL))
+  {
+      dbus_message_unref (message);
+      message = NULL;
+  }
+    
+finish_error7:
+  if(message)
+      dbus_message_unref (message);
+}
+dbus_bool_t
+CheckInstalledSpooler ()
+{
+  syslog (LOG_DEBUG, "CheckInstalledSpooler()");
+  DBusMessage *message = NULL;
+  DBusMessage *reply = NULL;
+  DBusPendingCall *pending_call = NULL;
+  DBusConnection *connection = NULL;
+  DBusError error;
+  dbus_bool_t ok = FALSE;
+  
+  dbus_error_init (&error);
+  connection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
+  message = dbus_message_new_method_call (DBUS_SERVICE_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_PATH_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_INTERFACE_ORG_FREEDESKTOP_DBUS,
+                                          "CheckInstalledSpooler");
+  if (message == NULL)
+    goto finish_error8;
+
+  if (!dbus_connection_send_with_reply (connection, message, &pending_call, 360000))
+  {
+    dbus_message_unref (message);
+    goto finish_error8;
+  }
+ 
+  if (pending_call == NULL)
+    goto finish_error8;
+
+  dbus_pending_call_block(pending_call);
+
+  reply = dbus_pending_call_steal_reply(pending_call);
+  if (reply == NULL)
+    goto finish_error8;
+
+  dbus_message_get_args (reply, NULL,
+                             DBUS_TYPE_BOOLEAN, &ok,
+                             DBUS_TYPE_INVALID);
+finish_error8:
+  if(message)
+      dbus_message_unref (message);
+  if(reply)
+      dbus_message_unref (reply);
+  if(pending_call)
+      dbus_pending_call_unref (pending_call);
+  return ok;
+
+}
+
+dbus_bool_t
+CheckInstalledDrivers ()
+{
+  syslog (LOG_DEBUG, "CheckInstalledDrivers()");
+  DBusMessage *message = NULL;
+  DBusMessage *reply = NULL;
+  DBusPendingCall *pending_call = NULL;
+  DBusConnection *connection = NULL;
+  DBusError error;
+  dbus_bool_t ok = FALSE;
+  
+  dbus_error_init (&error);
+  connection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
+  message = dbus_message_new_method_call (DBUS_SERVICE_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_PATH_ORG_FREEDESKTOP_DBUS,
+                                          DBUS_INTERFACE_ORG_FREEDESKTOP_DBUS,
+                                          "CheckInstalledDrivers");
+  if (message == NULL)
+    goto finish_error9;
+
+  dbus_message_append_args (message,
+                            DBUS_TYPE_STRING, &global_make,
+                            DBUS_TYPE_STRING, &global_model, DBUS_TYPE_INVALID);
+
+  if (!dbus_connection_send_with_reply (connection, message, &pending_call, 360000))
+  {
+    dbus_message_unref (message);
+    goto finish_error9;
+  }
+ 
+  if (pending_call == NULL)
+    goto finish_error9;
+
+  dbus_pending_call_block(pending_call);
+
+  reply = dbus_pending_call_steal_reply(pending_call);
+  if (reply == NULL)
+    goto finish_error9;
+
+  dbus_message_get_args (reply, NULL,
+                             DBUS_TYPE_BOOLEAN, &ok,
+                             DBUS_TYPE_INVALID);
+finish_error9:
+  if(message)
+      dbus_message_unref (message);
+  if(reply)
+      dbus_message_unref (reply);
+  if(pending_call)
+      dbus_pending_call_unref (pending_call);
+  return ok;
+
+}
+
 static int
 find_matching_device_uris (struct device_id *id,
 			   const char *usbserial,
@@ -1544,8 +1903,10 @@
 
   if (ippGetStatusCode (answer) > IPP_OK_CONFLICT)
     syslog (LOG_ERR, "IPP-Resume-Printer request failed");
-  else
+  else {
     syslog (LOG_INFO, "Re-enabled printer %s", printer_uri);
+    PrinterEnabled();
+  }
 
   ippDelete (answer);
   httpClose (cups);
@@ -1629,6 +1990,16 @@
 
   syslog (LOG_DEBUG, "MFG:%s MDL:%s SERN:%s serial:%s", id.mfg, id.mdl,
 	  id.sern ? id.sern : "-", usbserial[0] ? usbserial : "-");
+	  
+  global_make = id.mfg;
+  global_model = id.mdl;
+  CheckAndInstallDrivers();
+  if(!CheckInstalledDrivers())
+  {
+    MissingDriver();
+    syslog (LOG_DEBUG, "FAIL HERE");
+    exit(1);
+  }
 
   if (!is_bluetooth)
     {
@@ -1757,9 +2128,12 @@
 
   if (ippGetStatusCode (answer) > IPP_OK_CONFLICT)
     syslog (LOG_ERR, "IPP-Pause-Printer request failed");
-  else
+  else {
     syslog (LOG_INFO, "Disabled printer %s as the corresponding device "
 	    "was unplugged or turned off", printer_uri);
+  // PrinterDisabled();
+  // 
+  }
 
   ippDelete (answer);
   httpClose (cups);
@@ -1853,10 +2227,68 @@
 
   openlog ("udev-configure-printer", 0, LOG_LPR);
   cupsSetPasswordCB (no_password);
-  if (add)
-    return do_add (argv[0], argv[2]);
-  if (enumerate)
+  {
+    /* fork for time-intensive stuff (see udev doc) */
+    pid_t pid = fork();
+    if (pid < 0)
+    {
+      syslog (LOG_ERR, "Failed to fork a worker process");
+      return 1;
+    }
+    else if (pid > 0)
+    {
+      return 0;
+    }
+ 
+    if ( system( "rpm -q task-printing-server" ) != 0 ) 
+    {
+      syslog (LOG_DEBUG, "Cups isn't installed, let's install it");
+      /*
+       * We need to use dbus to ask the applet to install cups
+       */
+      InstallSpooler();
+      if(!CheckInstalledSpooler ())
+      {
+        InstallSpoolerFailed();
+        exit(1);
+      }
+   }
+   
+     if ( system("/bin/systemctl status cups") == 0 ) 
+    {
+      syslog (LOG_DEBUG, "Cups server not run");
+      /*
+       * We need run CUPS
+       */
+	 system("/bin/systemctl enable cups");
+	 system("/bin/systemctl start cups");
+        exit(1);
+      }
+
+   
+    if( system( "/bin/systemctl status cups") != 0 )
+    {
+      if( system( "/bin/systemctl restart cups") != 0 )
+      {
+        SpoolerStartFailed();
+        /* we cannot go ahead without cups running */
+        exit(1);
+      }
+    }
+  return do_add (argv[0], argv[2]);
+  }
+//  else
+//  {
+   if (enumerate)
     return 0; // no-op
 
+//  if(system("/sbin/service cups status") == 0)
+//  {
+//      /* if the cups daemon is running, notify on the desktop about the printer being disabled */
+//      PrinterDisabled();
+//  }*/
+//    return do_remove (argv[2]);
+//  }
+
   return do_remove (argv[2]);
 }
